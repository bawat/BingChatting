/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package GPTAPI;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.SearchContext;
import org.openqa.selenium.StaleElementReferenceException;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;

import SeleniumControls.HelperMethods;

import static SeleniumControls.HelperMethods.*;

//import io.github.bonigarcia.wdm.WebDriverManager;

public class ForgetfulBingChat {
	
	private static final boolean USE_URL_ARGS = true;
	public static void main(String[] args) {
		System.out.println("Response: " + getResponse("How to milk a cow", true));
	}
	
	private static WebDriver driver;
	public static String getResponse(String request) {
		return getResponse(request, false);
	}
    public static String getResponse(String request, boolean showBrowser) {
		driver = provideSilentSelenium(showBrowser);
		
		if(USE_URL_ARGS) {
			try {
				driver.get("https://www.bing.com/search?showconv=1&sendquery=1&q=" + URLEncoder.encode(request, StandardCharsets.UTF_8.toString()));
			} catch (UnsupportedEncodingException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			
		} else {
			driver.get("https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx");
			
			try {
				waitUntilFound(driver, By.cssSelector("#bnp_btn_accept")).click();
			} catch (TimeoutException e) {
				
			}
		}
		
		WebElement searchBox;
		SearchContext shadowRoot1 = null, shadowRoot2 = null, shadowRoot3 = null;
		for(int i = 0; i < 3; i++) {
			try {
				shadowRoot1 = waitUntilFound(driver, By.cssSelector(".cib-serp-main")).getShadowRoot();
				shadowRoot2 = waitUntilFound(shadowRoot1, By.cssSelector("#cib-action-bar-main")).getShadowRoot();
				shadowRoot3 = waitUntilFound(shadowRoot2, By.cssSelector("cib-text-input")).getShadowRoot();
				searchBox = waitUntilFound(shadowRoot3, By.cssSelector("#searchbox"));
				break;
			} catch(NoSuchElementException e) {
				e.printStackTrace();
				driver.navigate().refresh();
				System.out.println("Trying again...");
			}
		}
		
		
		if(!USE_URL_ARGS){
			pauseOneSecond();
			
			new Actions(driver).sendKeys(searchBox, request, Keys.chord(Keys.ENTER)).build().perform();
		}
		
		waitUntilBingHasFinishedPrinting(shadowRoot2);
		
		
		SearchContext shadowRootConversation;
		SearchContext shadowRootChatTurn;
		SearchContext shadowRootBotResponse;
		SearchContext shadowRootBotMessageBox;
		WebElement response;
		
		//Repeatedly redo the tree search process, just in case the elements get stale be them being regenerated by Bing
		while(true) {
			try {
				shadowRootConversation = waitUntilFound(shadowRoot1, By.cssSelector("#cib-conversation-main")).getShadowRoot();
				shadowRootChatTurn = waitUntilFound(shadowRootConversation, By.cssSelector("cib-chat-turn")).getShadowRoot();
				shadowRootBotResponse = waitUntilFound(shadowRootChatTurn, By.cssSelector("cib-message-group[source=\"bot\"]")).getShadowRoot();
				shadowRootBotMessageBox = waitUntilFound(shadowRootBotResponse, By.cssSelector("cib-message[type=\"text\"]")).getShadowRoot();
				
				response = waitUntilFound(shadowRootBotMessageBox, By.cssSelector(".ac-textBlock"));
				
				break;
			} catch(StaleElementReferenceException e) {
			}

			pauseOneSecond();
			continue;
		}
		
		String responseText = response.getText();
        driver.quit();
        
        return responseText;
    }

	private static WebElement waitUntilFound(SearchContext toSearch, By toFind) {
		return HelperMethods.waitUntilFound(driver, toSearch, toFind);
	}
	
	private static void waitUntilBingHasFinishedPrinting(SearchContext shadowRoot) {
    	SearchContext shadowRootTypingIndicator = waitUntilFound(shadowRoot, By.cssSelector("cib-typing-indicator")).getShadowRoot();
		WebElement stopTypingButton = waitUntilFound(shadowRootTypingIndicator, By.cssSelector("#stop-responding-button"));
		
		while(!"true".equalsIgnoreCase(stopTypingButton.getAttribute("disabled"))) {
			try {
				Thread.yield();
				Thread.sleep(1000l);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}


