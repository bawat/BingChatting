/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package BingChatLib;

import java.time.Duration;
import java.time.temporal.ChronoUnit;

import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.SearchContext;
import org.openqa.selenium.StaleElementReferenceException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.FluentWait;

import io.github.bonigarcia.wdm.WebDriverManager;

public class Library {
	private static WebDriver driver;
    public static String getResponse(String request) {
    	WebDriverManager.chromedriver().setup();
		
		ChromeOptions chromeOptions = new ChromeOptions();
		chromeOptions.addArguments("--remote-allow-origins=*");
		chromeOptions.addArguments("--disable-extensions");
		chromeOptions.addArguments("--disable-gpu");
		chromeOptions.addArguments("--no-sandbox");
		chromeOptions.addArguments("--log-level=OFF");
		chromeOptions.addArguments("--silent");
		
		chromeOptions.addArguments("--output=/dev/null");
		chromeOptions.addArguments("--disable-in-process-stack-traces");
		chromeOptions.addArguments("--disable-logging");
		chromeOptions.addArguments("--disable-dev-shm-usage");
		chromeOptions.addArguments("--disable-crash-reporter");
		chromeOptions.addArguments("--window-size=1920,1080");
		
		chromeOptions.addArguments("--headless=new");
		System.setProperty("webdriver.chrome.silentOutput", "true");
		//System.setProperty("webdriver.http.factory", "apache");
		driver = new ChromeDriver(chromeOptions);

		driver.get("https://www.bing.com/search?q=Bing+AI&showconv=1&FORM=hpcodx");
		
		
		waitUntilFound(driver, By.cssSelector("#bnp_btn_accept")).click();
		
		SearchContext shadowRoot1 = waitUntilFound(driver, By.cssSelector(".cib-serp-main")).getShadowRoot();
		SearchContext shadowRoot2 = waitUntilFound(shadowRoot1, By.cssSelector("#cib-action-bar-main")).getShadowRoot();
		SearchContext shadowRoot3 = waitUntilFound(shadowRoot2, By.cssSelector("cib-text-input")).getShadowRoot();
		WebElement searchBox = waitUntilFound(shadowRoot3, By.cssSelector("#searchbox"));
		
		try {
			Thread.sleep(1000l);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		new Actions(driver).sendKeys(searchBox, request, Keys.chord(Keys.ENTER)).build().perform();
		//shadowRoot2.findElement(By.cssSelector("cib-chat-turn"))
		
		//Wait until chatgpt has finished printing
			SearchContext shadowRootTypingIndicator = waitUntilFound(shadowRoot2, By.cssSelector("cib-typing-indicator")).getShadowRoot();
			WebElement stopTypingButton = waitUntilFound(shadowRootTypingIndicator, By.cssSelector("#stop-responding-button"));
			
			while(!"true".equalsIgnoreCase(stopTypingButton.getAttribute("disabled"))) {
				try {
					Thread.yield();
					Thread.sleep(1000l);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		
		SearchContext shadowRootConversation;
		SearchContext shadowRootChatTurn;
		SearchContext shadowRootBotResponse;
		SearchContext shadowRootBotMessageBox;
		WebElement response;
		
		while(true) {
			try {
				shadowRootConversation = waitUntilFound(shadowRoot1, By.cssSelector("#cib-conversation-main")).getShadowRoot();
				shadowRootChatTurn = waitUntilFound(shadowRootConversation, By.cssSelector("cib-chat-turn")).getShadowRoot();
				shadowRootBotResponse = waitUntilFound(shadowRootChatTurn, By.cssSelector("cib-message-group[source=\"bot\"]")).getShadowRoot();
				shadowRootBotMessageBox = waitUntilFound(shadowRootBotResponse, By.cssSelector("cib-message[type=\"text\"]")).getShadowRoot();
				
				response = waitUntilFound(shadowRootBotMessageBox, By.cssSelector(".ac-textBlock"));
				
				break;
			} catch(StaleElementReferenceException e) {
			}

			try {
				Thread.yield();
				Thread.sleep(1000l);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			continue;
		}
		
		String responseText = response.getText();
        driver.quit();
        
        return responseText;
    }
    
    private static WebElement waitUntilFound(SearchContext toSearch, By toFind) {
    	FluentWait<WebDriver> fluentWait = new FluentWait<>(driver)
    	        .withTimeout(Duration.of(10l, ChronoUnit.SECONDS))
    	        .pollingEvery(Duration.of(200l, ChronoUnit.MILLIS))
    	        .ignoring(NoSuchElementException.class);
    	
    	fluentWait.until(new ExpectedCondition<Boolean>() {
            public Boolean apply(WebDriver d) {
                return toSearch.findElement(toFind).isDisplayed();
            }
        });
    	
    	return toSearch.findElement(toFind);
	}

	public static void main(String[] args) {
		System.out.println("Response: " + getResponse("How to milk a cow"));
	}
}
